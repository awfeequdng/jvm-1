### 判断对象是否已死

#### 引用计数法

> 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值减1；任何时刻计数器值为0的对象就是不可能再被使用的对象。
>
> 优点：实现简单，判定效率高
>
> 缺点：无法解决对象间循环引用问题

#### 可达性分析算法

> 通过一系列作为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，说明这个对象不可用。`GC Roots`对象包括：
>
> 1. 虚拟机栈中引用的对象
> 2. 本地方法栈中`native`方法引用的对象
> 3. 方法区中类静态属性引用的对象
> 4. 方法区中常量引用的对象

### 引用分类

####  强引用

> 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象

#### 软引用

> 在系统将要发生内存溢出时才会回收的对象，jdk1.2之后用`SoftReference`类实现软引用

#### 弱引用

> 垃圾收集器工作时，无论内存空间是否足够，弱引用对象都会被回收。jdk1.2之后用`WeakReference`类实现弱引用

#### 虚引用

> 无法通过虚引用获取对象实例，它存在的唯一作用就是在这个对象被回收时收到一个系统通知。jdk1.2之后用`PhantomReference`类实现虚引用

### 真正判断对象是否需要回收

- 回收一个对象要经过两次标记过程：
  1. 进行可达性分析后没有与`GC Roots`相连的引用。
  2. 是否执行`finalize()`方法。
     - 如果不执行或已经执行过，那么这个对象就被回收
     - 如果重写了`finalize()`方法并且未被执行过，就将这个对象放置在`F-Queue`队列中，由低优先级的`Finalizer`线程去执行。执行这个方法的过程中如果与引用链上的对象建立关联，那么这个对象就可以避免被回收。
- **任何一个对象的`finalize()`方法都只会被系统调用一次**。

### final finally finalize区别

#### final

- 用来修饰类，方法，变量
  - 修饰类时，该类不能被其他类所继承，`final`类中所有的成员方法都会隐式的定义为`final`方法。
  - 修饰方法时，把方法锁定，以防止继承类对其进行更改。
  - 修饰变量时，这个变量表示常量，只能被赋值一次，不能再改变

#### finally

- `finally`作为异常处理的一部分，只能用在`try-catch`块中，并且会附带一个语句块，在`try`块的代码得到执行后这个语句块一般会被执行

  特殊情况：`try`中执行了`System.exit(0)`；线程在执行`try`或`catch`时被中断了。

#### finalize

- `finalize`是`java.lang.Object`类中定义的，每个对象都有这个方法。一个对象的finalize()方法只会被调用一次，在垃圾回收器执行时会调用被回收对象的`finalize()`方法，可以覆盖此方法来实现对其他资源的回收.

### 方法区的垃圾回收

- 方法区中垃圾回收性价比比较低，远低于堆

- 主要回收内容：废弃常量、无用的类
  - 判断类是否为“无用的类”的三个条件：
    1. 该类的所有实例都被回收
    2. 加载该类的`ClassLoader`被回收
    3. 该类的`java.lang.Class`对象没有被引用，无法在任何地方通过反射访问该类的方法。